4,10c4
< //
< //Solves the min cost flow problem given integer arc capacities, unit costs, 
< //and divergence values using the epsilon relaxation algorithm with epsilon 
< //scaling. In simple terms, it finds a flow vector
< //x indexed by the arcs of the graph that yields the minimum cost and 
< //has the specified divergence values at every node.
< //
---
> //Solves the min cost flow problem given integer arc capacities, unit costs, and divergence values using the epsilon relaxation algorithm with epsilon scaling
13,79c7
< //
< //Make sure that file.dat is formatted correctly as below
< //Problem format: Row 1 indicates |N| and |A|. Rows 2 to |A|+1 correspond
< // to arcs, indicating the start node, end node, cost, upper capacity of
< // each arc. (lower capacity is assumed to be zero.) 
< //The last |N| rows correspond to nodes, indicating the supply at each node.
< //
< //Four example data sets are included and are posted
< //by Paul Tseng on his website
< //
< //Details given about these data sets are:
< //mcnf1.dat: |N|=4, |A|=5, optimal cost = 14
< //mcnf2.dat: |N|=20, |A|=80, optimal cost = 30464
< //mcnf3.dat: |N|=49, |A|=520, optimal cost = 1.73566449E+11 (corrected) (caution: this network has some parallel arcs)
< //mcnf4.dat: |N|=10000, |A|=60000, optimal cost = 21514702 (maybe)
< //
< //
< //Also note that in C++ arrays start at index 0 
< //(but the data format lists node labels starting from 1),
< //so adjustments had to be made accordingly as to how the data was processed
< //In particular, we will subtract 1 from each node label 
< //(i.e. node 1 is instead referred to as node 0).
< //
< //--------------------------------------------------------//
< //Algorithm Description:
< //
< //Complimentary Epsilon Slackness Condition:
< //
< //A given flow x and potential u satisfy epsilon-complimentary slackness if
< //for all arcs j~(i,i'), d[j] + u[i] - u[i'] is
< //1. in the interval [-epsilon, epsilon] if 0 < x[j] < c[j]
< //2. >= -epsilon if 0 = x[j]
< //3. <= epsilon if x[j] = c[j]
< //
< //Algorithm steps:
< //
< //Initialization: 
< //1. Set u[i] = 0 for all nodes i.
< //2. For each arc j~(i,i'), compute r[j] = d[j] + u[i] - u[i']
< //3. Initialize flow x by calling initflow(x,r,A,c)
< //4. Set e = epsilon = maximum degree of any node so that x and u
< //   satisfy epsilon-complimentary slackness condition.
< //5. Compute node surplus s[i]= (net flow into node i) - b[i]
< //
< //Main algorithm:
< //1. If s[i] = 0 for all nodes i, then x is feasible, so stop.
< //   Else pick any node ibar with s[ibar] > 0.
< //   
< //   while( s[ibar] != 0 )
< //   1. paint each arc j~(i,i'):
< //      - white if r[j] \in [-e, -e/2] and x[j] < c[j]
< //      - black if r[j] \in [e/2, e] and x[j] > 0
< //      - red otherwise
< //   2. If there is a black arc jbar out of ibar, then decrease
< //        x[jbar] by min{x[jbar], s[ibar]}.
< //      else if there is a white arc jbar into ibar, then increase
< //        x[jbar] by min{c[jbar] - x[jbar], s[ibar]}.
< //   3. Else increase u[ibar] 
< //      by as much as possible while maintaining e-comlimentary slackness
< //      In particular, set u[ibar] = u[ibar] + alpha where
< //      alpha = min{ (-r[j] + e such that j~(ibar, i') and x[j] > 0), 
< //                   ( r[j] + e such that j~(i',ibar) and x[j] < c[j]) }
< //   end if
< //   end while
< //   go to 1.
< //
< //------------------------------------------------------//
---
> //Make sure that file.dat is formatted correctly
94d21
< //simple routine to return the minimum of two doubles
103d29
< //simple routine to return the minimum of two integers
112,115c38
< //given the vector v (for our uses it is a vector of node labels),
< //minpot1 finds the minimum value of -r when restricted to the vector v
< //of indices (node labels).
< double minpot1( vector<int> v, vector<double> r ){
---
> double minpot1( vector<int> v, double *r ){
127,129c50
< //same as minpot1, except that minpot2 finds the minimum value component of r 
< //(not -r) when restricted to vector v of indices (node labels)
< double minpot2( vector<int> v, vector<double> r ){
---
> double minpot2( vector<int> v, double *r ){
142c63
< //initializes the flow x given a potential u. r is related to u
---
> //initializes x given a potential u. r is related to u
144c65
< void initflow( vector<int> x, vector<double> r, int A, vector<int> c){
---
> void initflow( int *x, double *r, int A, int *c){
146c67
<   for(i=0; i < A; i++){
---
>   for(i=1; i<=A; i++){
156c77
< double cost( vector<int> x, vector<int> d, int A){
---
> double cost( int *x, int *d, int A){
159c80
<   for(i = 0; i < A; i++){
---
>   for(i = 1; i<=A; i++){
166,167c87,88
< //and whether s = 0 (s is a vector indexed by nodes giving the surplus of supply at each node)
< bool checkfeas( vector<int> x, vector<int> c, vector<int> s, int A, int N){
---
> //and whether s = 0
> bool checkfeas( int *x, int *c, int *s, int A, int N){
168a90
>   bool feasible=true;
170,171c92,93
<   for(i=0; i < A; i++){
<     if( (x[i] > c[i]) || (x[i]<0) ){ return false; }
---
>   for(i=1; i<=A; i++){
>     if( (x[i] > c[i]) || (x[i]<0) ){ feasible = false; }
173,174c95,96
<   for(i=0; i < N; i++){
<     if(s[i] != 0){ return false; }
---
>   for(i=1; i<=N; i++){
>     if(s[i] != 0){ feasible = false; }
176c98
<   return true;
---
>   return feasible;
179c101
< void printflow( vector<int> x, int A){
---
> void printflow( int *x, int A){
181c103
<   for(i=0; i < A; i++){
---
>   for(i=1; i<=A; i++){
192,194d113
<   int m; int n;
<   int N; //number of nodes
<   int A; //number of arcs
204c123
<   N = databuffer;
---
>   const int N = databuffer;
206c125
<   A = databuffer;
---
>   const int A = databuffer;
208,210c127,129
<   vector<int> startnode(A);
<   vector<int> endnode(A);
<   vector<int> d(A); //unit cost on each arc
---
>   int startnode[A];
>   int endnode[A];
>   int d[A];
212,214c131,133
<   vector<int> c(A); //upper capacity on each arc
<   vector<int> b(N); //supply at each node
<   vector<int> degree(N); //degree of each node
---
>   int c[A]; //upper capacity on each arc
>   int b[N]; //supply at each node
>   int degree[N]; //degree of each node
217c136
<   for(j=0; j < N; j++){ degree[j] = 0; } //initialize degree of each node to zero
---
>   for(j=1; j <= N; j++){ degree[j] = 0; } //initialize degree of each node to zero
221,222c140,141
<   i=0;
<   while(i < A ){
---
>   i=1;
>   while(i <= A ){
224d142
<     databuffer -= 1;
229d146
<     databuffer -= 1;
241,242c158,159
<   i = 0;
<   while(i < N ){
---
>   i = 1;
>   while(i <= N ){
249a167,170
> // for(i=1; i<=A; i++){
> //     cout<<startnode[i]<<"   "<<endnode[i]<<"   "<<d[i]<<"   "<<c[i]<<endl;
> //   }
> 
252c173
<   for(j=0; j<N; j++){ 
---
>   for(j=1; j<=N; j++){ 
260,261d180
< vector< vector<int> > arcout(N, vector<int>(maxdeg));  //Records the indices from the array startnode[] corresponding to arcs out of each node
< vector< vector<int> > arcin(N, vector<int>(maxdeg));  //Records the indices from the array endnode[] corresponding to arcs into each node
263,264c182,184
< // int arcout[N][maxdeg]; Records the indices from the array startnode[] corresponding to arcs out of each node
< //  int arcin[N][maxdeg]; Records the indices from the array endnode[] corresponding to arcs into each node
---
>   int arcout[N][maxdeg]; //Records the indices from the array startnode[] corresponding to arcs out of each node
> 
>   int arcin[N][maxdeg]; //Records the indices from the array endnode[] corresponding to arcs into each node
266,267c186,187
<   vector<int> numarcout(N,0);
<   vector<int> numarcin(N,0);  //initialize so that there are zero arcs coming in or out of each node
---
>   int numarcout[N];
>   int numarcin[N];
268a189,193
>   //initialize so that there are zero arcs coming in or out of each node
>   for(i=1; i <= N; i++){
>     numarcout[i] = 0;
>     numarcin[i] = 0;
>   }
271,277c196,206
<   for(i=0; i < A; i++){
<     m = startnode[i];
<     n = endnode[i];
<     arcin[n][numarcin[n]] = i;
<     numarcin[n] += 1;
<     arcout[m][numarcout[m]] = i;
<     numarcout[m] += 1;
---
>   for(i=1; i <= A; i++){
>     j=numarcin[endnode[i]];
>     numarcin[endnode[i]] = j+1;
>     arcin[endnode[i]][numarcin[endnode[i]]] = i;
>     j = numarcout[startnode[i]];
>     numarcout[startnode[i]] = j+1;
>     arcout[startnode[i]][numarcout[startnode[i]]] = i;
>   }
>   //
>   for(i=1; i<=N; i++){
>     cout<<numarcin[i]<<"  "<<numarcout[i]<<endl;
278a208
>   //
281,282c211,212
<   maxd = fabs(double(d[0]));
<   for(i=0; i < A; i++){
---
>   maxd = fabs(double(d[1]));
>   for(i=1; i<=A; i++){
288,292c218,222
<   double e = maxd;  //initial choice of epsilon (large enough to zero node potential satisfies epsilon complimentary slackness
<   vector<double> u(N); //node potential
<   vector<int> x(A); //current flow
<   vector<double> r(A); //reduced cost d_j + u_i - u_i' for each arc
<   vector<int> s(N); //excess supply at each node, s = Ex - b
---
>   double e = maxd;
>   double u[N];
>   int x[A];
>   double r[A]; //reduced cost d_j + u_i - u_i' for each arc
>   int s[N]; //excess supply at each node, s = Ex - b
297c227
<   for(i=0; i < N; i++){
---
>   for(i=1; i<=N; i++){
300,301c230,231
<   //Initialize reduced cost r
<   for(i=0; i < A; i++){
---
>   //Choose x to be feasible and initialize reduced cost r
>   for(i=1; i<=A; i++){
302a233,256
>     if( r[i] >= 0){
>       x[i] = 0;
>     }else{
>       x[i] = c[i];
>     }
>   }
> 
>   //Compute s
>   for(i=1; i<=N; i++){
> 
>     s[i] = -b[i];
>     for(j=1; j<=numarcout[i]; j++){
>       s[i] = s[i] + x[arcout[i][j]];
>     }
>     for(j=1; j<=numarcin[i]; j++){
>       s[i] = s[i] - x[arcin[i][j]];
>     }
>   }
> 
>   //Put all nodes with positive s in the queue
>   for(i=1; i<=N; i++){
>     if(s[i] > 0){ 
>       nodeq.push_back(i);
>     }
307c261
<   //---------------------------------------------------------------------//
---
>  
311c265
<   int k; //k is always used as a temporary storage variable to simplify the code a bit
---
>   int k;
317c271
<   int arc; //temporary variable to store index of a given arc
---
>   int arc;
319c273
<   while(e >= 1/( double(N) )){
---
>   while(e >= 1/( double(N) )){  
321,324c275,283
<     //change flow so that it satisfies epsilon complemetary slackness 
<     //with respect to new epsilon.
< 
<     initflow(x,r,A,c);
---
>     //change flow so it satisfies epsilon complemetary slackness with respect
>     //to new epsilon.
>     for(i=1; i<=A; i++){
>       if( r[i] >= 0){
>     x[i] = 0;
>       }else{
>     x[i] = c[i];
>       }
>     }
326,327c285,286
<   //   Compute s and put nodes with positive s in queue
<     for(i=0; i < N; i++){
---
>   //   Compute s
>     for(i=1; i<=N; i++){
329c288
<     for(j=0; j < numarcout[i]; j++){
---
>     for(j=1; j<=numarcout[i]; j++){
333c292
<     for(j=0; j < numarcin[i]; j++){
---
>     for(j=1; j<=numarcin[i]; j++){
337,338d295
<     if(s[i]>0){
<       nodeq.push_back(i);
339a297,302
>     
>     //Put all nodes with positive s in queue
>     for(i=1; i<=N; i++){
>       if(s[i] > 0){ 
>     nodeq.push_back(i);
>       }
341a305,306
>     cout<<"reached this point"<<endl;
> 
352c317
<     for(j=0; j<numarcout[ibar] && proceed == true; j++){
---
>     for(j=1; j<=numarcout[ibar] && proceed == true; j++){
365,367c330,332
<       x[k] -= beta;
<       s[ibar] -= beta;
<       s[endnode[k]] += beta;
---
>       x[k] = x[k] - beta;
>       s[ibar] = s[ibar] - beta;
>       s[endnode[k]] = s[endnode[k]] + beta;
375c340
<       for( j=0; j<numarcin[ibar] && proceed==true; j++ ){
---
>       for( j=1; j<=numarcin[ibar] && proceed==true; j++ ){
386a352,353
>       cout<<"reached this point 2"<<endl;
>       cout<<numarcin[1]<<endl;
391,393c358,360
<         x[k] += beta;
<         s[ibar] -= beta;
<         s[startnode[k]] += beta;
---
>         x[k] = x[k] + beta;
>         s[ibar] = s[ibar] - beta;
>         s[startnode[k]] = s[startnode[k]] + beta;
401a369
>     cout<<numarcin[1]<<endl;
407c375
<       for(j=0; j < numarcout[ibar]; j++){
---
>       for(j=1; j <= numarcout[ibar]; j++){
420c388
<         for(j=0; j < numarcin[ibar]; j++){
---
>         for(j=1; j <= numarcin[ibar]; j++){
441c409
<         for(j=0; j < numarcin[ibar]; j++){
---
>         for(j=1; j <= numarcin[ibar]; j++){
448a417
>     cout<<numarcin[1]<<endl;
453c422
<       for(j=0; j < numarcout[ibar]; j++){
---
>       for(j=numarcout[ibar]; j >= 1; j--){
455c424
<         r[k] += alpha;
---
>         r[k] = r[k] + alpha;
457c426
<       for(j=0; j < numarcin[ibar]; j++){
---
>       for(j=numarcin[ibar]; j >= 1; j--){
459c428
<         r[k] -= alpha;
---
>         r[k] = r[k] - alpha;
460a430,431
>       cout<<numarcin[1]<<endl;
>       cout<<"stuff"<<endl;
464a436,439
>     cout<<"iteration complete"<<endl;
>     for(i=1; i<=N; i++){
>     cout<<numarcin[i]<<"  "<<numarcout[i]<<endl;
>     }
466a442,446
>   }
> 
>   cout<<"A = "<<A<<endl;
>   for(i=1; i<=N; i++){
>     cout<<numarcin[i]<<"  "<<numarcout[i]<<endl;
